// packages/api/src/api-services.ts
@mixcore/api implementation:
<<<CONTENT>>>
import type { ApiServiceConfig } from '@mixcore/shared';
import type { ApiResult, RestApiResult } from '@mixcore/shared';

export type { ApiResult, RestApiResult };

/**
 * ApiService
 * Framework-agnostic, TypeScript-native API client for Mixcore
 *
 * @remarks
 * Refactored from legacy AngularJS service. All SPA dependencies removed.
 * Configuration is injected via constructor.
 */

export type ApiServiceHook = {
  onRequest?: (req: RequestInit & { url: string }) => void | Promise<void>;
  onResponse?: (res: Response, req: RequestInit & { url: string }) => void | Promise<void>;
};

export class ApiService implements ApiService {
  private config: ApiServiceConfig;
  private hooks: ApiServiceHook[] = [];

  constructor(config: ApiServiceConfig) {
    this.config = config;
  }

  /**
   * Register a request/response hook
   */
  use(hook: ApiServiceHook) {
    this.hooks.push(hook);
  }

  /**
   * Generic GET request (returns ApiResult)
   */
  async get(endpoint: string, params?: Record<string, any>): Promise<ApiResult> {
    const url = new URL(endpoint, this.config.apiBaseUrl);
    if (params) {
      Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, String(v)));
    }
    const req: RequestInit & { url: string } = {
      url: url.toString(),
      headers: this.config.apiKey ? { 'Authorization': `Bearer ${this.config.apiKey}` } : undefined,
    };
    for (const hook of this.hooks) if (hook.onRequest) await hook.onRequest(req);
    try {
      const res = await fetch(req.url, req);
      for (const hook of this.hooks) if (hook.onResponse) await hook.onResponse(res, req);
      const data = await res.json().catch(() => undefined);
      if (!res.ok) {
        return { isSucceed: false, data, errors: [res.statusText], status: res.status };
      }
      return { isSucceed: true, data, status: res.status };
    } catch (err) {
      return { isSucceed: false, errors: [(err as Error).message] };
    }
  }

  /**
   * Generic POST request (returns ApiResult, supports JSON or FormData)
   */
  async post(endpoint: string, data: any, options?: { isFormData?: boolean }): Promise<ApiResult> {
    const url = new URL(endpoint, this.config.apiBaseUrl);
    let body: any = data;
    let headers: Record<string, string> = {};
    if (options?.isFormData) {
      // Let browser set Content-Type for FormData
      body = data;
    } else {
      body = JSON.stringify(data);
      headers['Content-Type'] = 'application/json';
    }
    if (this.config.apiKey) headers['Authorization'] = `Bearer ${this.config.apiKey}`;
    const req: RequestInit & { url: string } = {
      url: url.toString(),
      method: 'POST',
      headers,
      body,
    };
    for (const hook of this.hooks) if (hook.onRequest) await hook.onRequest(req);
    const res = await fetch(req.url, req);
    for (const hook of this.hooks) if (hook.onResponse) await hook.onResponse(res, req);
    const respData = await res.json().catch(() => undefined);
    if (!res.ok) {
      return { isSucceed: false, data: respData, errors: [res.statusText], status: res.status };
    }
    return { isSucceed: true, data: respData, status: res.status };
  }

  /**
   * Generic DELETE request (returns ApiResult)
   */
  async delete(endpoint: string): Promise<ApiResult> {
    const url = new URL(endpoint, this.config.apiBaseUrl);
    const req: RequestInit & { url: string } = {
      url: url.toString(),
      method: 'DELETE',
      headers: this.config.apiKey ? { 'Authorization': `Bearer ${this.config.apiKey}` } : undefined,
    };
    for (const hook of this.hooks) if (hook.onRequest) await hook.onRequest(req);
    try {
      const res = await fetch(req.url, req);
      for (const hook of this.hooks) if (hook.onResponse) await hook.onResponse(res, req);
      const data = await res.json().catch(() => undefined);
      if (!res.ok) {
        return { isSucceed: false, data, errors: [res.statusText], status: res.status };
      }
      return { isSucceed: true, data, status: res.status };
    } catch (err) {
      return { isSucceed: false, errors: [(err as Error).message] };
    }
  }
}
<<<END>>>

// packages/base/src/base-service.ts
@mixcore/base implementation:
<<<CONTENT>>>
/**
 * BaseService
 * Abstract base class for Mixcore SDK services
 *
 * @remarks
 * Refactored from legacy AngularJS service. All SPA dependencies removed.
 * Configuration is injected via constructor.
 */
export interface BaseServiceConfig {
  apiBaseUrl: string;
  apiKey?: string;
  [key: string]: any;
}

export abstract class BaseService {
  protected config: BaseServiceConfig;

  constructor(config: BaseServiceConfig) {
    this.config = config;
  }

  /**
   * Abstract method for error handling
   * @param error - Error object
   */
  abstract handleError(error: any): void;
}
<<<END>>>

// packages/config/src/configuration-services.ts
@mixcore/config implementation:
<<<CONTENT>>>
import { ApiService, ApiServiceConfig } from '@mixcore/shared';

/**
 * ConfigurationServices
 * TypeScript-native, framework-agnostic service for configuration management.
 * Migrated and refactored from legacy AngularJS ConfigurationService.
 */
export interface ConfigurationUpload {
  file: File;
  folder?: string;
  title?: string;
  description?: string;
}

export class ConfigurationServices {
  private api: ApiService;
  private readonly prefixUrl: string = '/configuration';

  constructor(api: ApiService) {
    this.api = api;
  }

  /**
   * Uploads a configuration file.
   * @param configurationFile - The configuration file and metadata
   * @returns API result
   */
  async uploadConfiguration(configurationFile: ConfigurationUpload): Promise<any> {
    if (!configurationFile.file) {
      throw new Error('No file provided');
    }
    const formData = new FormData();
    formData.append(configurationFile.file.name, configurationFile.file);
    if (configurationFile.folder) formData.append('fileFolder', configurationFile.folder);
    if (configurationFile.title) formData.append('title', configurationFile.title);
    if (configurationFile.description) formData.append('description', configurationFile.description);

    const req = {
      url: this.prefixUrl + '/upload',
      method: 'POST',
      body: formData,
      headers: {},
    };
    // Use fetch directly for FormData, bypassing ApiService's JSON logic
    const url = new URL(req.url, this.api['config'].apiBaseUrl).toString();
    const res = await fetch(url, {
      method: 'POST',
      body: formData,
      // Let browser set Content-Type for FormData
      headers: this.api['config'].apiKey ? { 'Authorization': `Bearer ${this.api['config'].apiKey}` } : undefined,
    });
    if (!res.ok) throw new Error(`Upload failed: ${res.status} ${res.statusText}`);
    return res.json();
  }
}
<<<END>>>

// packages/database/src/mix-database-data-rest-portal-service.ts
@mixcore/database implementation:
<<<CONTENT>>>
import type { ApiService } from '@mixcore/api';
import type { ApiResult } from '@mixcore/api';

/**
 * MixDatabaseDataRestPortalService
 * TypeScript-native, framework-agnostic service for Mixcore database data portal operations.
 * Migrated and refactored from legacy AngularJS RestMixDatabaseDataPortalService.
 */
export class MixDatabaseDataRestPortalService {
  private api: ApiService;
  private readonly prefixUrl: string = '/mix-database-data/portal';

  constructor(api: ApiService) {
    this.api = api;
  }

  /**
   * Saves additional data for a Mixcore database. Returns ApiResult.
   */
  async saveAdditionalData(objData: any): Promise<ApiResult> {
    const endpoint = `${this.prefixUrl}/save-additional-data`;
    return this.api.post(endpoint, objData);
  }

  /**
   * Gets additional data for a Mixcore database. Returns ApiResult.
   */
  async getAdditionalData(data?: any): Promise<ApiResult> {
    let endpoint = `${this.prefixUrl}/additional-data`;
    if (data && typeof data === 'object' && Object.keys(data).length > 0) {
      const params = new URLSearchParams(data).toString();
      endpoint += `?${params}`;
    }
    return this.api.get(endpoint);
  }

  /**
   * Initializes data for a Mixcore database by name. Returns ApiResult.
   */
  async initData(mixDatabaseName: string): Promise<ApiResult> {
    if (!mixDatabaseName) {
      return { isSucceed: false, errors: ['Missing mixDatabaseName'] };
    }
    const endpoint = `${this.prefixUrl}/init/${mixDatabaseName}`;
    return this.api.get(endpoint);
  }

  /**
   * Exports data for a Mixcore database. Returns ApiResult.
   */
  async export(objData?: any): Promise<ApiResult> {
    let endpoint = `${this.prefixUrl}/export`;
    if (objData && typeof objData === 'object' && Object.keys(objData).length > 0) {
      const params = new URLSearchParams(objData).toString();
      endpoint += `?${params}`;
    }
    return this.api.get(endpoint);
  }

  /**
   * Imports data for a Mixcore database. Returns ApiResult.
   */
  async import(mixDatabaseName: string, file: File): Promise<ApiResult> {
    if (!mixDatabaseName) {
      return { isSucceed: false, errors: ['Missing mixDatabaseName'] };
    }
    if (!file) {
      return { isSucceed: false, errors: ['Missing file'] };
    }
    const endpoint = `${this.prefixUrl}/import-data/${mixDatabaseName}`;
    if (!mixDatabaseName) {
      return { isSucceed: false, errors: ['Missing mixDatabaseName'] };
    }
    if (!file) {
      return { isSucceed: false, errors: ['Missing file'] };
    }
    const formData = new FormData();
    formData.append('file', file);
    return this.api.post(endpoint, formData, { isFormData: true });
  }

  /**
   * Migrates data for a Mixcore database. Returns ApiResult.
   */
  async migrate(mixDatabaseId: string): Promise<ApiResult> {
    if (!mixDatabaseId) {
      return { isSucceed: false, errors: ['Missing mixDatabaseId'] };
    }
    const endpoint = `${this.prefixUrl}/migrate-data/${mixDatabaseId}`;
    return this.api.get(endpoint);
  }
}
<<<END>>>

// packages/file/src/file-services.ts
@mixcore/file implementation:
<<<CONTENT>>>
import type { ApiService, FileServices } from '@mixcore/shared';

export class FileServicesPortal implements FileServices {
  private api: ApiService;
  private prefixUrl = '/file/';

  constructor(api: ApiService) {
    this.api = api;
  }

  async getFile(folder: string, filename: string) {
    const url = `${this.prefixUrl}details?folder=${encodeURIComponent(folder)}&filename=${encodeURIComponent(filename)}`;
    return this.api.get(url);
  }

  async initFile(type: string) {
    return this.api.get(`${this.prefixUrl}init/${encodeURIComponent(type)}`);
  }

  async getFiles(request: any) {
    return this.api.post(`${this.prefixUrl}list`, request);
  }

  async removeFile(fullPath: string) {
    return this.api.get(`${this.prefixUrl}delete/?fullPath=${encodeURIComponent(fullPath)}`);
  }

  async saveFile(file: any) {
    return this.api.post(`${this.prefixUrl}save`, file);
  }

  async uploadFile(file: File, folder: string) {
    const url = `${this.prefixUrl}upload-file`;
    const formData = new FormData();
    formData.append('folder', folder);
    formData.append('file', file);
    // Use fetch directly for multipart/form-data
    const res = await fetch(url, {
      method: 'POST',
      body: formData,
    });
    if (!res.ok) throw new Error(`UPLOAD ${url}: ${res.status} ${res.statusText}`);
    return res.json();
  }
}
<<<END>>>